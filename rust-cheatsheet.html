
<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <link rel="icon" type="image/png" href="favicon32.png">
    <link
        href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <!-- <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css"> -->
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">

    <title>Rust Language Cheat Sheet</title>

    <!-- CSS -->
    <link rel="stylesheet" href="https://cheats.rs/book.css">
    <link rel="stylesheet" href="https://cheats.rs/prism.css">
</head>

<body>

    <div class="page">
        <div class="page__content">

            <div class="book-content">
                <h1></h1>
                <p><img id="logo" src="/logo.png"></img></p>
<div class="title">Rust Language Cheat Sheet</div>
<div class="subtitle">09.08.2019</div>
<blockquote>
<p>Contains clickable links to
<strong>The Book</strong> <a href="https://doc.rust-lang.org/book/"><sup class="entry">BK</sup></a>,
<strong>Rust by Example</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/"><sup class="entry">EX</sup></a>,
<strong>Std Docs</strong> <a href="https://doc.rust-lang.org/std"><sup class="mid">STD</sup></a>,
<strong>Nomicon</strong> <a href="https://doc.rust-lang.org/nightly/nomicon/"><sup class="expert">NOM</sup></a>,
<strong>Reference</strong> <a href="https://doc.rust-lang.org/stable/reference/"><sup class="expert">REF</sup></a>.
Other symbols used:
largely <strong>deprecated</strong> <sup>üóëÔ∏è</sup>,
has a <strong>minimum edition</strong> <sup>'18</sup>,
is <strong>work in progress</strong> <sup>üöß</sup>,
or <strong>bad</strong> <sup>üõë</sup>.</p>
</blockquote>
<div class="controls">
    <a id="toggle_ligatures" href="javascript:toggle_ligatures()">Fira Code Ligatures (<code>..=, =></code>)</a>
    <a href="javascript:toggle_night_mode()">Night Mode &#x1f4a1;</a>
</div>
<div class="noprint">
<div class="toc">
<div class="column">
<p>Language Constructs</p>
<ul>
<li><a href="https://cheats.rs/#data-structures">Data Structures</a></li>
<li><a href="https://cheats.rs/#references-pointers">References &amp; Pointers</a></li>
<li><a href="https://cheats.rs/#functions-behavior">Functions &amp; Behavior</a></li>
<li><a href="https://cheats.rs/#control-flow">Control Flow</a></li>
<li><a href="https://cheats.rs/#organizing-code">Organizing Code</a></li>
<li><a href="https://cheats.rs/#type-aliases-and-casts">Type Aliases and Casts</a></li>
<li><a href="https://cheats.rs/#macros-attributes">Macros &amp; Attributes</a></li>
<li><a href="https://cheats.rs/#pattern-matching">Pattern Matching</a></li>
<li><a href="https://cheats.rs/#generics-constraints">Generics &amp; Constraints</a></li>
<li><a href="https://cheats.rs/#strings-chars">Strings &amp; Chars</a></li>
<li><a href="https://cheats.rs/#comments">Comments</a></li>
<li><a href="https://cheats.rs/#miscellaneous">Miscellaneous</a></li>
</ul>
</div>
<div class="column">
<p>Guides</p>
<ul>
<li><a href="https://cheats.rs/#invisible-sugar">Invisible Sugar</a></li>
<li><a href="https://cheats.rs/#closures">Closures</a></li>
<li><a href="https://cheats.rs/#idiomatic-rust">Idiomatic Rust</a></li>
<li><a href="https://cheats.rs/#a-guide-to-reading-lifetimes">A Guide to Reading Lifetimes</a></li>
<li><a href="https://cheats.rs/#formatting-strings">Formatting Strings</a></li>
<li><a href="https://cheats.rs/#tooling">Tooling</a></li>
</ul>
<p>Misc</p>
<ul>
<li><a href="https://cheats.rs/#links-services">Links &amp; Services</a></li>
<li><a href="https://cheats.rs/#printing-pdf">Printing &amp; PDF</a></li>
</ul>
</div>
</div>
</div>
<div class="noprint">
<h2 id="hello-rust">Hello, Rust!</h2>
<p>If you have never seen Rust before, or if you want to try the things below:</p>
<div id="hellostatic">
<pre><code>fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
</div>
<div id="helloplay"></div>
<div id="helloctrl"><a href="javascript:show_playground(true);">‚ñ∂Ô∏è Edit & Run</a></div>
</div>
<h3 id="data-structures">Data Structures</h3>
<p>Data types and memory locations defined via keywords.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>struct S {}</code></td><td>Define a <strong>struct</strong> <a href="https://doc.rust-lang.org/book/ch05-00-structs.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/structs.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/std/keyword.struct.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/struct-expr.html"><sup class="expert">REF</sup></a> with named fields.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>struct S { x: T }</code></td><td>Define struct with named field <code>x</code> of type <code>T</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>struct S</code>‚Ää‚Äã<code>(T);</code></td><td>Define &quot;tupled&quot; struct with numbered field <code>.0</code> of type <code>T</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>struct S;</code></td><td>Define zero sized unit struct.</td></tr>
<tr><td><code>enum E {}</code></td><td>Define an <strong>enum</strong> <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/enum.html#enums"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/enumerations.html"><sup class="expert">REF</sup></a> , <em>c</em>. <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>, <a href="https://en.wikipedia.org/wiki/Tagged_union">tagged unions</a>.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>enum E { A, B</code>‚Äã<code>(), C {} }</code></td><td>Define variants of enum; can be unit- <code>A</code>, tuple- <code>B</code>‚Ää‚Äã<code>()</code> and struct-like <code>C{}</code>.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>enum E { A = 1 }</code></td><td>If variants are only unit-like, allow discriminant values, e.g., for FFI.</td></tr>
<tr><td><code>union U {}</code></td><td>Unsafe C-like <strong>union</strong>  <a href="https://doc.rust-lang.org/stable/reference/items/unions.html"><sup class="expert">REF</sup></a> for FFI compatibility.</td></tr>
<tr><td><code>static X: T = T();</code></td><td><strong>Global variable</strong> <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/constants.html#constants"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/static-items.html#static-items"><sup class="expert">REF</sup></a>  with <code>'static</code> lifetime, single memory location.</td></tr>
<tr><td><code>const X: T = T();</code></td><td>Defines <strong>constant</strong> <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/constants.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/constant-items.html"><sup class="expert">REF</sup></a>. Copied into a temporary when used.</td></tr>
<tr><td><code>let x: T;</code></td><td>Allocate <code>T</code> bytes on stack bound as <code>x</code>. Assignable once, not mutable.</td></tr>
<tr><td><code>let mut x: T;</code></td><td>Like <code>let</code>, but allow for mutability and mutable borrow. <sup>*</sup></td></tr>
<tr><td><span class="hidemobile">    </span> <code>x = y;</code></td><td>Moves <code>y</code> to <code>x</code>, invalidating <code>y</code> if <code>T</code> is not <code>Copy</code>, and copying <code>y</code> otherwise.</td></tr>
</tbody></table>
</div>
<div class="footnotes">
    <sup>*</sup> Note that technically <i>mutable</i> and <i>immutable</i>
    are a bit of a misnomer. Even if you have an immutable binding or shared
    reference, it might contain a
    <a href="https://doc.rust-lang.org/std/cell/index.html">Cell</a>,
    which supports so called <i>interior mutability</i>.
</div>
<div>&nbsp;</div>
<p>Creating and accessing data structures; and some more <em>sigilic</em> types.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>S { x: y }</code></td><td>Create <code>struct S {}</code> or <code>use</code>'ed <code>enum E::S {}</code> with field <code>x</code> set to <code>y</code>.</td></tr>
<tr><td><code>S { x }</code></td><td>Same, but use local variable <code>x</code> for field <code>x</code>.</td></tr>
<tr><td><code>S { ..s }</code></td><td>Fill remaining fields from <code>s</code>, esp. useful with <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a>.</td></tr>
<tr><td><code>S { 0: x }</code></td><td>Like <code>S</code>‚Ää‚Äã<code>(x)</code> below, but set field <code>.0</code> with struct syntax.</td></tr>
<tr><td><code>S</code>‚Äã‚Ää<code>(x)</code></td><td>Create <code>struct S</code>‚Ää‚Äã<code>(T)</code> or <code>use</code>'ed <code>enum E::S</code>‚Äã‚Ää<code>()</code> with field <code>.0</code> set to <code>x</code>.</td></tr>
<tr><td><code>S</code></td><td>If <code>S</code> is unit <code>struct S;</code> or <code>use</code>'ed <code>enum E::S</code> create value of <code>S</code>.</td></tr>
<tr><td><code>E::C { x: y }</code></td><td>Create enum variant <code>C</code>. Other methods above also work.</td></tr>
<tr><td><code>()</code></td><td>Empty tuple, both literal and type, aka <strong>unit</strong> <a href="https://doc.rust-lang.org/std/primitive.unit.html"><sup class="mid">STD</sup></a></td></tr>
<tr><td><code>(x)</code></td><td>Parenthesized expression.</td></tr>
<tr><td><code>(x,)</code></td><td>Single-element <strong>tuple</strong> expression. <a href="https://doc.rust-lang.org/stable/rust-by-example/primitives/tuples.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/std/primitive.tuple.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/tuple-expr.html"><sup class="expert">REF</sup></a></td></tr>
<tr><td><code>(S,)</code></td><td>Single-element tuple type.</td></tr>
<tr><td><code>[S]</code></td><td>Array type of unspecified length, i.e., <strong>slice</strong>. <a href="https://doc.rust-lang.org/std/primitive.slice.html"><sup class="mid">STD</sup></a>  <a href="https://doc.rust-lang.org/stable/rust-by-example/primitives/array.html"><sup class="entry">EX</sup></a>  <a href="https://doc.rust-lang.org/stable/reference/types.html#array-and-slice-types"><sup class="expert">REF</sup></a> Can't live on stack. <sup>*</sup></td></tr>
<tr><td><code>[S; n]</code></td><td><strong>Array type</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/primitives/array.html"><sup class="entry">EX</sup></a>  <a href="https://doc.rust-lang.org/std/primitive.array.html"><sup class="mid">STD</sup></a> of fixed length <code>n</code> holding elements of type <code>S</code>.</td></tr>
<tr><td><code>[x; n]</code></td><td>Array instance with <code>n</code> copies of <code>x</code>. <a href="https://doc.rust-lang.org/stable/reference/expressions/array-expr.html"><sup class="expert">REF</sup></a></td></tr>
<tr><td><code>[x, y]</code></td><td>Array instance with given elements <code>x</code> and <code>y</code>.</td></tr>
<tr><td><code>x[0]</code></td><td>Collection indexing. Overloadable <a href="https://doc.rust-lang.org/std/ops/trait.Index.html">Index</a>, <a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html">IndexMut</a></td></tr>
<tr><td><code>x[..]</code></td><td>Collection slice-like indexing via <a href="https://doc.rust-lang.org/std/ops/struct.RangeFull.html">RangeFull</a>, <em>c</em>. slices.</td></tr>
<tr><td><code>x[a..]</code></td><td>Collection slice-like indexing via <a href="https://doc.rust-lang.org/std/ops/struct.RangeFrom.html">RangeFrom</a>.</td></tr>
<tr><td><code>x[..b]</code></td><td>Collection slice-like indexing <a href="https://doc.rust-lang.org/std/ops/struct.RangeTo.html">RangeTo</a>.</td></tr>
<tr><td><code>x[a..b]</code></td><td>Collection slice-like indexing via <a href="https://doc.rust-lang.org/std/ops/struct.Range.html">Range</a>.</td></tr>
<tr><td><code>a..b</code></td><td>Right-exclusive <strong>range</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/range-expr.html"><sup class="expert">REF</sup></a> creation, also seen as <code>..b</code>.</td></tr>
<tr><td><code>a..=b</code></td><td>Inclusive range creation, also seen as <code>..=b</code>.</td></tr>
<tr><td><code>s.x</code></td><td>Named <strong>field access</strong>, <a href="https://doc.rust-lang.org/stable/reference/expressions/field-expr.html"><sup class="expert">REF</sup></a> might try to <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a> if <code>x</code> not part of type <code>S</code>.</td></tr>
<tr><td><code>s.0</code></td><td>Numbered field access, used for tuple types <code>S</code>‚Ää‚Äã<code>(T)</code>.</td></tr>
</tbody></table>
</div>
<div class="footnotes">
    <sup>*</sup> For now, see <a href="https://github.com/rust-lang/rust/issues/48055">tracking issue</a> and corresponding <a href="https://github.com/rust-lang/rfcs/pull/1909">RFC 1909</a>.
</div>
<h3 id="references-pointers">References &amp; Pointers</h3>
<p>Granting access to un-owned memory. Also see section on Generics &amp; Constraints.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>&amp;S</code></td><td>Shared <strong>reference</strong> <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/std/primitive.reference.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/nightly/nomicon/references.html"><sup class="expert">NOM</sup></a> <a href="https://doc.rust-lang.org/stable/reference/types.html#pointer-types"><sup class="expert">REF</sup></a> (space for holding <em>any</em> <code>&amp;s</code>).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>&amp;[S]</code></td><td>Special slice reference that contains (<code>address</code>, <code>length</code>).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>&amp;str</code></td><td>Special string reference that contains (<code>address</code>, <code>length</code>).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>&amp;dyn S</code></td><td>Special <strong>trait object</strong> <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types"><sup class="entry">BK</sup></a> reference that contains (<code>address</code>, <code>vtable</code>).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>&amp;mut S</code></td><td>Exclusive reference to allow mutability (also <code>&amp;mut [S]</code>, <code>&amp;mut dyn S</code>, ...)</td></tr>
<tr><td><code>*const S</code></td><td>Immutable <strong>raw pointer type</strong> <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/std/primitive.pointer.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/types.html#raw-pointers-const-and-mut"><sup class="expert">REF</sup></a> w/o memory safety.</td></tr>
<tr><td><code>*mut S</code></td><td>Mutable raw pointer type w/o memory safety.</td></tr>
<tr><td><code>&amp;s</code></td><td>Shared <strong>borrow</strong> <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/scope/borrow.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><sup class="mid">STD</sup></a> (e.g., address, len, vtable, ... of <em>this</em> <code>s</code>, like <code>0x1234</code>).</td></tr>
<tr><td><code>&amp;mut s</code></td><td>Exclusive borrow that allows <strong>mutability</strong>. <a href="https://doc.rust-lang.org/stable/rust-by-example/scope/borrow/mut.html"><sup class="entry">EX</sup></a></td></tr>
<tr><td><code>ref s</code></td><td><strong>Bind by reference</strong>. <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#legacy-patterns-ref-and-ref-mut"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/scope/borrow/ref.html"><sup class="entry">EX</sup></a> <sup>üóëÔ∏è</sup></td></tr>
<tr><td><code>*r</code></td><td><strong>Dereference</strong> <a href="https://doc.rust-lang.org/book/ch15-02-deref.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/nightly/nomicon/vec-deref.html"><sup class="expert">NOM</sup></a> a reference <code>r</code> to access what it points to.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>*r = s;</code></td><td>If <code>r</code> is a mutable reference, move or copy <code>s</code> to target memory.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>s = *r;</code></td><td>Make <code>s</code> a copy of whatever <code>r</code> references, if that is <code>Copy</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>s = *my_box;</code></td><td><a href="https://www.reddit.com/r/rust/comments/b4so6i/what_is_exactly/ej8xwg8/">Special case</a> for <code>Box</code> that can also move out Box'ed content if it isn't <code>Copy</code>.</td></tr>
<tr><td><code>'a</code></td><td>A <strong>lifetime parameter</strong>, <a href="https://doc.rust-lang.org/book/ch10-00-generics.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/nightly/nomicon/lifetimes.html"><sup class="expert">NOM</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/generics.html#type-and-lifetime-parameters"><sup class="expert">REF</sup></a>, duration of a flow in static analysis.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>&amp;'a S</code></td><td>Only accepts a <code>s</code> with an address that lives <code>'a</code> or longer.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>&amp;'a mut S</code></td><td>Same, but allow content of address to be changed.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>S&lt;'a&gt;</code></td><td>Signals <code>S</code> will contain address with lifetime <code>'a</code>. Creator of <code>S</code> decides <code>'a</code>.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>fn f&lt;'a&gt;(t: &amp;'a T)</code></td><td>Same, for function. Caller decides <code>'a</code>.</td></tr>
<tr><td><code>'static</code></td><td>Special lifetime lasting the entire program execution.</td></tr>
</tbody></table>
</div>
<h3 id="functions-behavior">Functions &amp; Behavior</h3>
<p>Define units of code and their abstractions.</p>
<div class="cheats">
<table><thead><tr><th>Sigil</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>trait T {}</code></td><td>Define a <strong>trait</strong>. <a href="https://doc.rust-lang.org/book/ch10-02-traits.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/traits.html"><sup class="expert">REF</sup></a></td></tr>
<tr><td><code>trait T : R {}</code></td><td><code>T</code> is subtrait of <strong>supertrait</strong> <a href="https://doc.rust-lang.org/stable/reference/items/traits.html#supertraits"><sup class="expert">REF</sup></a> <code>R</code>. Any <code>S</code> must <code>impl R</code> before it can <code>impl T</code>.</td></tr>
<tr><td><code>impl S {}</code></td><td><strong>Implementation</strong> <a href="https://doc.rust-lang.org/stable/reference/items/implementations.html"><sup class="expert">REF</sup></a> of functionality for a type <code>S</code>.</td></tr>
<tr><td><code>impl T for S {}</code></td><td>Implement trait <code>T</code> for type <code>S</code>.</td></tr>
<tr><td><code>impl !T for S {}</code></td><td>Disable an automatically derived <strong>auto trait</strong> <a href="https://doc.rust-lang.org/nightly/nomicon/send-and-sync.html"><sup class="expert">NOM</sup></a> <a href="https://doc.rust-lang.org/stable/reference/special-types-and-traits.html#auto-traits"><sup class="expert">REF</sup></a>.</td></tr>
<tr><td><code>fn f() {}</code></td><td>Definition of a <strong>function</strong> <a href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html"><sup class="entry">BK</sup></a>  <a href="https://doc.rust-lang.org/stable/rust-by-example/fn.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/functions.html"><sup class="expert">REF</sup></a>; or associated function if inside <code>impl</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>fn f() -&gt; S {}</code></td><td>Same, returning a value of type S.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>fn f(&amp;self) {}</code></td><td>Define a method as part of an <code>impl</code>.</td></tr>
<tr><td><code>const fn f() {}</code></td><td>Constant <code>fn</code> usable at compile time, e.g., <code>const X: u32 = f(Y)</code>. <sup>'18</sup></td></tr>
<tr><td><code>async fn f() {}</code></td><td><strong>Async</strong> <sup>üöß</sup> <sup>'18</sup> function transformation, makes <code>f</code> return an <code>impl Future</code>. <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><sup class="mid">STD</sup></a></td></tr>
<tr><td><span class="hidemobile">    </span> <code>async fn f() -&gt; S {}</code></td><td>The call <code>f()</code> returns an <code>impl Future&lt;Output=S&gt;</code>, does not execute <code>f</code>!</td></tr>
<tr><td><span class="hidemobile">    </span> <code>async {}</code></td><td>Block <code>async { x }</code> transforms last expression <code>x</code> into <code>Future&lt;Output=X&gt;</code>.</td></tr>
<tr><td><code>fn() -&gt; S</code></td><td><strong>Function pointers</strong>, <a href="https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html#function-pointers"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/std/primitive.fn.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/types.html#function-pointer-types"><sup class="expert">REF</sup></a> don't confuse with trait <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a>.</td></tr>
<tr><td><code>|| {} </code></td><td>A <strong>closure</strong> <a href="https://doc.rust-lang.org/book/ch13-01-closures.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/closure-expr.html"><sup class="expert">REF</sup></a> that borrows its captures.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>|x| {}</code></td><td>Closure with a bound parameter <code>x</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>|x| x + x</code></td><td>Closure without block expression.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>move |x| x + y </code></td><td>Closure taking ownership of its captures.</td></tr>
<tr><td><span class="hidemobile">    </span> <code> return || true </code></td><td>Closures may sometimes look like logical ORs (here: return a closure).</td></tr>
<tr><td><code>f()</code></td><td>Invoke callable <code>f</code> (e.g., a function, closure, function pointer, <code>Fn</code>, ...).</td></tr>
<tr><td><code>x.f()</code></td><td>Call member function, requires <code>f</code> takes <code>self</code>, <code>&amp;self</code>, ... as first argument.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>X::f(x)</code></td><td>Same as <code>x.f()</code>. Unless <code>impl Copy for X {}</code>, <code>f</code> can only be called once.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>X::f(&amp;x)</code></td><td>Same as <code>x.f()</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>X::f(&amp;mut x)</code></td><td>Same as <code>x.f()</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>S::f(&amp;x)</code></td><td>Same as <code>x.f()</code> if <code>X</code> <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">derefs</a> to <code>S</code> (i.e., <code>x.f()</code> finds methods of <code>S</code>).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>T::f(&amp;x)</code></td><td>Same as <code>x.f()</code> if <code>X impl T</code> (i.e., <code>x.f()</code> finds methods of <code>T</code> if in scope).</td></tr>
<tr><td><code>X::f()</code></td><td>Call associated function, e.g., <code>X::new()</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>&lt;X as T&gt;::f()</code></td><td>Call trait method <code>T::f()</code> implemented for <code>X</code>.</td></tr>
<tr><td><code>unsafe {}</code></td><td>If you need to crash your code in production; <strong>unsafe code</strong>. <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html?highlight=unsafe#unsafe-superpowers"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/unsafe.html#unsafe-operations"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/nightly/nomicon/meet-safe-and-unsafe.html"><sup class="expert">NOM</sup></a> <a href="https://doc.rust-lang.org/stable/reference/unsafe-blocks.html#unsafe-blocks"><sup class="expert">REF</sup></a></td></tr>
</tbody></table>
</div>
<h3 id="control-flow">Control Flow</h3>
<p>Control execution within a function.</p>
<div class="cheats">
<table><thead><tr><th>Sigil</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>while x {}</code></td><td><strong>Loop</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html#predicate-loops"><sup class="expert">REF</sup></a>, run while expression <code>x</code> is true.</td></tr>
<tr><td><code>loop {}</code></td><td><strong>Loop infinitely</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html#infinite-loops"><sup class="expert">REF</sup></a> until <code>break</code>. Can yield value with <code>break x</code>.</td></tr>
<tr><td><code>for x in iter {}</code></td><td>Syntactic sugar to loop over <strong>iterators</strong>. <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/std/iter/index.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html#iterator-loops"><sup class="expert">REF</sup></a></td></tr>
<tr><td><code>if x {} else {}</code></td><td><strong>Conditional branch</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/if-expr.html"><sup class="expert">REF</sup></a> if expression is true.</td></tr>
<tr><td><code>'label: loop {}</code></td><td><strong>Loop label</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/flow_control/loop/nested.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html#loop-labels"><sup class="expert">REF</sup></a>, useful for flow control in nested loops.</td></tr>
<tr><td><code>break</code></td><td><strong>Break expression</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html#break-expressions"><sup class="expert">REF</sup></a> to exit a loop.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>break x</code></td><td>Same, but make <code>x</code> value of the loop expression (only in actual <code>loop</code>).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>break 'label</code></td><td>Exit not only this loop, but the enclosing one marked with <code>'label</code>.</td></tr>
<tr><td><code>continue </code></td><td><strong>Continue expression</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html#continue-expressions"><sup class="expert">REF</sup></a> to the next loop iteration of this loop.</td></tr>
<tr><td><code>continue 'label</code></td><td>Same, but instead of enclosing loop marked with <code>'label</code>.</td></tr>
<tr><td><code>x.await</code></td><td>Only works inside <code>async</code>. Yield flow until <a href="https://doc.rust-lang.org/std/future/trait.Future.html">Future</a> or Stream <sup>?</sup> <code>x</code> ready. <sup>üöß</sup> <sup>'18</sup></td></tr>
<tr><td><code>return x</code></td><td>Early return from function. More idiomatic way is to end with expression.</td></tr>
<tr><td><code>x?</code></td><td>If <code>x</code> is <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err">Err</a> or <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None">None</a>, <strong>return and propagate</strong>. <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/error/result/enter_question_mark.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#the-question-mark-operator"><sup class="expert">REF</sup></a></td></tr>
</tbody></table>
</div>
<h3 id="organizing-code">Organizing Code</h3>
<p>Segment projects into smaller units and minimize dependencies.</p>
<div class="cheats">
<table><thead><tr><th>Sigil</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>mod m {}</code></td><td>Define a <strong>module</strong> <a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/mod.html#modules"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/modules.html#modules"><sup class="expert">REF</sup></a>, get definition from inside <code>{}</code>.</td></tr>
<tr><td><code>mod m;</code></td><td>Define a module, get definition from <code>m.rs</code> or <code>m/mod.rs</code>.</td></tr>
<tr><td><code>a::b</code></td><td>Namespace <strong>path</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/mod/use.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/paths.html"><sup class="expert">REF</sup></a> to element <code>b</code> within <code>a</code> (<code>mod</code>, <code>enum</code>, ...).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>::b</code></td><td>Search <code>b</code> relative to crate root. <sup>üóëÔ∏è</sup></td></tr>
<tr><td><span class="hidemobile">    </span> <code>crate::b</code></td><td>Search <code>b</code> relative to crate root. <sup>'18</sup></td></tr>
<tr><td><span class="hidemobile">    </span> <code>self::b</code></td><td>Search <code>b</code> relative to current module.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>super::b</code></td><td>Search <code>b</code> relative to parent module.</td></tr>
<tr><td><code>use a::b;</code></td><td><strong>Use</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/mod/use.html#the-use-declaration"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/use-declarations.html"><sup class="expert">REF</sup></a>  <code>b</code> directly in this scope without requiring <code>a</code> anymore.</td></tr>
<tr><td><code>use a::{b, c};</code></td><td>Same, but bring <code>b</code> and <code>c</code> into scope.</td></tr>
<tr><td><code>use a::b as x;</code></td><td>Bring <code>b</code> into scope but name <code>x</code>, like <code>use std::error::Error as E</code>.</td></tr>
<tr><td><code>use a::b as _;</code></td><td>Bring <code>b</code> anonymously into scope, useful for traits with conflicting names.</td></tr>
<tr><td><code>use a::*;</code></td><td>Bring everything from <code>a</code> into scope.</td></tr>
<tr><td><code>pub use a::b;</code></td><td>Bring <code>a::b</code> into scope and reexport from here.</td></tr>
<tr><td><code>pub T</code></td><td>&quot;Public if parent path is public&quot; <strong>visibility</strong> <a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><sup class="entry">BK</sup></a> for <code>T</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>pub(crate) T</code></td><td>Visible at most in current crate.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>pub(self) T</code></td><td>Visible at most in current module.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>pub(super) T</code></td><td>Visible at most in parent.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>pub(in a::b) T</code></td><td>Visible at most in <code>a::b</code>.</td></tr>
<tr><td><code>extern crate a;</code></td><td>Declare dependency on external <strong>crate</strong> <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#using-a-crate-to-get-more-functionality"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/crates/link.html#extern-crate"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/extern-crates.html#extern-crate-declarations"><sup class="expert">REF</sup></a> <sup>üóëÔ∏è</sup> ; just <code>use a::b</code> in <sup>'18</sup>.</td></tr>
<tr><td><code>extern &quot;C&quot; fn</code></td><td>External dependency for <strong>FFI</strong>. <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/std_misc/ffi.html#foreign-function-interface"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/nightly/nomicon/ffi.html#calling-foreign-functions"><sup class="expert">NOM</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/external-blocks.html#external-blocks"><sup class="expert">REF</sup></a></td></tr>
</tbody></table>
</div>
<h3 id="type-aliases-and-casts">Type Aliases and Casts</h3>
<p>Short-hand names of types, and methods to convert one type to another.</p>
<div class="cheats">
<table><thead><tr><th>Sigil</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>type T = S;</code></td><td>Create a <strong>type alias</strong> <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/type-aliases.html?highlight=alias#type-aliases"><sup class="expert">REF</sup></a>, i.e., another name for <code>S</code>.</td></tr>
<tr><td><code>Self</code></td><td>Type alias for <strong>implementing type</strong> <a href="https://doc.rust-lang.org/stable/reference/types.html#self-types"><sup class="expert">REF</sup></a>, e.g. <code>fn new() -&gt; Self</code>.</td></tr>
<tr><td><code>self</code></td><td>Method subject in <code>fn f(self) {}</code>, same as <code>fn f(self: Self) {}</code>.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>&amp;self</code></td><td>Same, but refers to self as borrowed, same as <code>f(self: &amp;Self)</code></td></tr>
<tr><td><span class="hidemobile">    </span>  <code>&amp;mut self</code></td><td>Same, but mutably borrowed, same as <code>f(self: &amp;mut Self)</code></td></tr>
<tr><td><span class="hidemobile">    </span>  <code>self: Box&lt;Self&gt;</code></td><td><a href="https://github.com/withoutboats/rfcs/blob/arbitray-receivers/text/0000-century-of-the-self-type.md">Arbitrary self type</a>, add methods to smart pointers (<code>my_box.f_of_self()</code>).</td></tr>
<tr><td><code>S as T</code></td><td><strong>Disambiguate</strong> <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/call-expr.html#disambiguating-function-calls"><sup class="expert">REF</sup></a> type <code>S</code> as trait <code>T</code>, e.g., <code>&lt;X as T&gt;::f()</code>.</td></tr>
<tr><td><code>S as R</code></td><td>In <code>use</code> of symbol, import <code>S</code> as <code>R</code>, e.g., <code>use a::b as x</code>.</td></tr>
<tr><td><code>x as u32</code></td><td>Primitive <strong>cast</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/types/cast.html#casting"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#type-cast-expressions"><sup class="expert">REF</sup></a>, may truncate and be a bit surprising. <a href="https://doc.rust-lang.org/nightly/nomicon/casts.html"><sup class="expert">NOM</sup></a></td></tr>
</tbody></table>
</div>
<h3 id="macros-attributes">Macros &amp; Attributes</h3>
<p>Code generation constructs expanded before the actual compilation happens.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>m!()</code></td><td><strong>Macro</strong> <a href="https://doc.rust-lang.org/book/ch19-06-macros.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/std/index.html#macros"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/macros.html"><sup class="expert">REF</sup></a> invocation, also <code>m!{}</code>, <code>m![]</code> (depending on macro).</td></tr>
<tr><td><code>$x:ty</code></td><td>Macro capture, also <code>$x:expr</code>, <code>$x:ty</code>, <code>$x:path</code>, ... see next table.</td></tr>
<tr><td><code>$x</code></td><td>Macro substitution in <strong>macros by example</strong>. <a href="https://doc.rust-lang.org/book/ch19-06-macros.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/macros.html#macro_rules"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html"><sup class="expert">REF</sup></a></td></tr>
<tr><td><code>$(x),*</code></td><td>Macro repetition &quot;zero or more times&quot; in macros by example.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>$(x),?</code></td><td>Same, but &quot;zero or one time&quot;.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>$(x),+</code></td><td>Same, but &quot;one or more times&quot;.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>$(x)&lt;&lt;+</code></td><td>In fact separators other than <code>,</code> are also accepted. Here: <code>&lt;&lt;</code>.</td></tr>
<tr><td><code>$crate</code></td><td>Special hygiene variable, crate where macros is defined. <sup>?</sup></td></tr>
<tr><td><code>#[attr]</code></td><td>Outer <strong>attribute</strong>. <a href="https://doc.rust-lang.org/stable/rust-by-example/attribute.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/attributes.html"><sup class="expert">REF</sup></a>, annotating the following item.</td></tr>
<tr><td><code>#![attr]</code></td><td>Inner attribute, annotating the surrounding item.</td></tr>
</tbody></table>
</div>
<div>&nbsp;</div>
<p>In a <code>macro_rules!</code> implementation, the following macro captures can be used:</p>
<div class="cheats">
<table><thead><tr><th>Macro Capture</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>$x:item</code></td><td>An item, like a function, struct, module, etc.</td></tr>
<tr><td><code>$x:block</code></td><td>A block <code>{}</code> of statements or expressions, e.g., <code>{ let x = 5; }</code></td></tr>
<tr><td><code>$x:stmt</code></td><td>A statement, e.g., <code>let x = 1 + 1;</code>, <code>String::new();</code> or <code>vec![];</code></td></tr>
<tr><td><code>$x:expr</code></td><td>An expression, e.g., <code>x</code>, <code>1 + 1</code>, <code>String::new()</code> or <code>vec![]</code></td></tr>
<tr><td><code>$x:pat</code></td><td>A pattern, e.g., <code>Some(t)</code>, <code>(17, 'a')</code> or <code>_</code>.</td></tr>
<tr><td><code>$x:ty</code></td><td>A type, e.g., <code>String</code>, <code>usize</code> or <code>Vec&lt;u8&gt;</code>.</td></tr>
<tr><td><code>$x:ident</code></td><td>An identifier, for example in <code>let x = 0;</code> the identifier is <code>x</code>.</td></tr>
<tr><td><code>$x:path</code></td><td>A path (e.g. <code>foo</code>, <code>::std::mem::replace</code>, <code>transmute::&lt;_, int&gt;</code>, ‚Ä¶).</td></tr>
<tr><td><code>$x:literal</code></td><td>A literal (e.g. <code>3</code>, <code>&quot;foo&quot;</code>, <code>b&quot;bar&quot;</code>, etc.).</td></tr>
<tr><td><code>$x:meta</code></td><td>A meta item; the things that go inside <code>#[...]</code> and <code>#![...]</code> attributes.</td></tr>
<tr><td><code>$x:tt</code></td><td>A single token tree, <a href="https://stackoverflow.com/a/40303308">see here</a> for more details.</td></tr>
</tbody></table>
</div>
<h3 id="pattern-matching">Pattern Matching</h3>
<p>Constructs found in <code>match</code> or <code>let</code> expressions, or function parameters.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>match m {}</code></td><td>Initiate <strong>pattern matching</strong> <a href="https://doc.rust-lang.org/book/ch06-02-match.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/flow_control/match.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/match-expr.html"><sup class="expert">REF</sup></a>, then use match arms, <em>c</em>. next table.</td></tr>
<tr><td><code>let S(x) = get();</code></td><td>Notably, <code>let</code> also pattern matches similar to the table below.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>let S { x } = s;</code></td><td>Only <code>x</code> will be bound to value <code>s.x</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>let (_, b, _) = abc;</code></td><td>Only <code>b</code> will be bound to value <code>abc.1</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>let (a, ..) = abc;</code></td><td>Ignoring 'the rest' also works.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>let Some(x) = get();</code></td><td><strong>Won't</strong> work <sup>üõë</sup> if pattern can be <strong>refuted</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/if-expr.html#if-let-expressions"><sup class="expert">REF</sup></a>, use <code>if let</code> instead.</td></tr>
<tr><td><code>if let Some(x) = get() {}</code></td><td>Branch if pattern can actually be assigned (e.g., <code>enum</code> variant).</td></tr>
<tr><td><code>fn f(S { x }: S)</code></td><td>Function parameters also work like <code>let</code>, here <code>x</code> bound to <code>s.x</code> of <code>f(s)</code>.</td></tr>
</tbody></table>
</div>
<div>&nbsp;</div>
<p>Pattern matching arms in <code>match</code> expressions. The left side of these arms can also be found in <code>let</code> expressions.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>E::A =&gt; {}</code></td><td>Match enum variant <code>A</code>, <em>c</em>. <strong>pattern matching</strong>. <a href="https://doc.rust-lang.org/book/ch06-02-match.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/flow_control/match.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions/match-expr.html"><sup class="expert">REF</sup></a></td></tr>
<tr><td><code>E::B ( .. ) =&gt; {}</code></td><td>Match enum tuple variant <code>B</code>, wildcard any index.</td></tr>
<tr><td><code>E::C { .. } =&gt; {}</code></td><td>Match enum struct variant <code>C</code>, wildcard any field.</td></tr>
<tr><td><code>S { x: 0, y: 1 } =&gt; {}</code></td><td>Match struct with specific params.</td></tr>
<tr><td><code>S { x, y } =&gt; {}</code></td><td>Match struct with any values, bind respective fields as variables <code>x</code> and <code>y</code>.</td></tr>
<tr><td><code>S { .. } =&gt; {}</code></td><td>Match struct with any values.</td></tr>
<tr><td><code>D =&gt; {}</code></td><td>Match enum variant <code>E::D</code> if <code>D</code> in <code>use</code>.</td></tr>
<tr><td><code>D =&gt; {}</code></td><td>Match anything, bind <code>D</code>; possibly false friend <sup>üõë</sup> of <code>E::D</code> if <code>D</code> not in <code>use</code>.</td></tr>
<tr><td><code>_ =&gt; {}</code></td><td>Proper wildcard that matches anything / &quot;all the rest&quot;.</td></tr>
<tr><td><code>[a, 0] =&gt; {}</code></td><td>Match array with any value for <code>a</code> and <code>0</code> for second.</td></tr>
<tr><td><code>(a, 0) =&gt; {}</code></td><td>Match tuple with any value for <code>a</code> and <code>0</code> for second.</td></tr>
<tr><td><code>x @ 1..=5 =&gt; {}</code></td><td>Bind matched to <code>x</code>; <strong>pattern binding</strong> <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#a-bindings"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/flow_control/match/binding.html#binding"><sup class="entry">EX</sup></a>.</td></tr>
<tr><td><code>0 | 1 =&gt; {}</code></td><td>Pattern alternatives (or-patterns).</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>E::A | E::Z </code></td><td>Same, but on enum variants.</td></tr>
<tr><td><span class="hidemobile">    </span>  <code>E::C {x} | E::D {x}</code></td><td>Same, but bind <code>x</code> if all variants have it.</td></tr>
<tr><td><code>S { x } if x &gt; 10</code></td><td>Pattern match <strong>guards</strong>. <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/flow_control/match/guard.html#guards"><sup class="entry">EX</sup></a></td></tr>
</tbody></table>
</div>
<!-- This is more relevant for let D = ... cases, https://www.reddit.com/r/rust/comments/a1846o/rust_quiz_26_medium_to_hard_rust_questions_with/eaop291/ -->
<!-- |  `D => {}` | Match struct if `D` unit `struct D;`| -->
<h3 id="generics-constraints">Generics &amp; Constraints</h3>
<p>Generics combine with many other constructs such as <code>struct S&lt;T&gt;</code>, <code>fn f&lt;T&gt;()</code>, ...</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>S&lt;T&gt;</code></td><td>A <strong>generic</strong> <a href="https://doc.rust-lang.org/book/ch10-01-syntax.html"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/generics.html"><sup class="entry">EX</sup></a> type with a type parameter (<code>T</code> is placeholder name here).</td></tr>
<tr><td><code>S&lt;T: R&gt;</code></td><td>Type short hand <strong>trait bound</strong> <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/generics/bounds.html"><sup class="entry">EX</sup></a> specification  (<code>R</code> <em>must</em> be actual trait).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>T: R, P: S</code></td><td><strong>Independent trait bounds</strong> (here one for <code>T</code> and one for <code>P</code>).</td></tr>
<tr><td><span class="hidemobile">    </span> <code>T: R, S</code></td><td>Compile error <sup>üõë</sup>, you probably want compound bound <code>R + S</code> below.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>T: R + S</code></td><td><strong>Compound trait bound</strong> <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#multiple-trait-bounds-with-"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/generics/multi_bounds.html"><sup class="entry">EX</sup></a>, <code>T</code> must fulfill <code>R</code> and <code>S</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>T: R + 'a</code></td><td>Same, but w. lifetime. <code>T</code> must fulfill <code>R</code>, if <code>T</code> has lifetimes, must outlive <code>'a</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>T: ?Sized</code></td><td>Opt out of a pre-defined trait bound, here <code>Sized</code>. <sup>?</sup></td></tr>
<tr><td><span class="hidemobile">    </span> <code>T: 'a</code></td><td>Type <strong>lifetime bound</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime/lifetime_bounds.html"><sup class="entry">EX</sup></a>; if T has references, they must outlive <code>'a</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>'b: 'a</code></td><td>Lifetime <code>'b</code> must live at least as long as (i.e., <em>outlive</em>) <code>'a</code> bound.</td></tr>
<tr><td><code>S&lt;T&gt; where T: R</code></td><td>Same as <code>S&lt;T: R&gt;</code> but more pleasant to read for longer bounds.</td></tr>
<tr><td><code>S&lt;T = R&gt;</code></td><td><strong>Default type parameter</strong> <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#default-generic-type-parameters-and-operator-overloading"><sup class="entry">BK</sup></a> for associated type.</td></tr>
<tr><td><code>S&lt;'_&gt;</code></td><td>Inferred <strong>anonymous lifetime</strong>.</td></tr>
<tr><td><code>S&lt;_&gt;</code></td><td>Inferred <strong>anonymous type</strong>, e.g., as <code>let x: Vec&lt;_&gt; = iter.collect()</code></td></tr>
<tr><td><code>S::&lt;T&gt;</code></td><td><strong>Turbofish</strong> <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><sup class="mid">STD</sup></a> call site type disambiguation, e.g. <code>f::&lt;u32&gt;()</code>.</td></tr>
<tr><td><code>trait T&lt;X&gt; {}</code></td><td>A trait generic over <code>X</code>. Can have multiple <code>impl T for S</code> (one per <code>X</code>).</td></tr>
<tr><td><code>trait T { type X; }</code></td><td>Defines <strong>associated type</strong> <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/reference/items/associated-items.html#associated-types"><sup class="expert">REF</sup></a> <code>X</code>. Only one <code>impl T for S</code> possible.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>type X = R;</code></td><td>Set associated type within <code>impl T for S { type X = R; }</code>.</td></tr>
<tr><td><code>impl&lt;T&gt; S&lt;T&gt; {}</code></td><td>Implement functionality for any <code>T</code> in <code>S&lt;T&gt;</code>.</td></tr>
<tr><td><code>impl S&lt;T&gt; {}</code></td><td>Implement functionality for exactly <code>S&lt;T&gt;</code> (e.g., <code>S&lt;u32&gt;</code>).</td></tr>
<tr><td><code>fn f() -&gt; impl T</code></td><td><strong>Existential types</strong> <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-traits"><sup class="entry">BK</sup></a>, returns an unknown-to-caller <code>S</code> that <code>impl T</code>.</td></tr>
<tr><td><code>fn f(x: &amp;impl T)</code></td><td>Trait bound,&quot;<strong>impl traits</strong>&quot; <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#trait-bounds"><sup class="entry">BK</sup></a>, somewhat similar to <code>fn f&lt;S:T&gt;(x: &amp;S)</code>.</td></tr>
<tr><td><code>fn f(x: &amp;dyn T)</code></td><td>Marker for <strong>dynamic dispatch</strong> <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/reference/types.html#trait-objects"><sup class="expert">REF</sup></a>, <code>f</code> will not be monomorphized.</td></tr>
<tr><td><code>fn f() where Self: R</code></td><td>In a <code>trait T {}</code>, mark <code>f</code> as accessible only on types that also <code>impl R</code>.</td></tr>
<tr><td><code>for&lt;'a&gt;</code></td><td><strong>Higher-rank trait bounds.</strong> <a href="https://doc.rust-lang.org/nightly/nomicon/hrtb.html"><sup class="expert">NOM</sup></a> <a href="https://doc.rust-lang.org/stable/reference/trait-bounds.html#higher-ranked-trait-bounds"><sup class="expert">REF</sup></a></td></tr>
</tbody></table>
</div>
<!-- These are a bit wonky to explain as they don't work everywhere and are a bit surprising. -->
<!-- | <span class="hidemobile">&nbsp;&nbsp;&nbsp;&nbsp;</span> `Box<dyn T>`  | Also works with other type parameters, here box with trait object `T`. | -->
<!-- | <span class="hidemobile">&nbsp;&nbsp;&nbsp;&nbsp;</span> `Box<impl T>`  | Box with an actual implementation of `T`. | -->
<h3 id="strings-chars">Strings &amp; Chars</h3>
<p>Rust has several ways to create string or char literals, depending on your needs.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>&quot;...&quot;</code></td><td><strong>String literal</strong> <a href="https://doc.rust-lang.org/stable/reference/tokens.html#string-literals"><sup class="expert">REF</sup></a>, will escape <code>\n</code>, ...</td></tr>
<tr><td><code>r&quot;...&quot;</code>,</td><td><strong>Raw string literal</strong>. <a href="https://doc.rust-lang.org/stable/reference/tokens.html#raw-string-literals"><sup class="expert">REF</sup></a>, won't escape <code>\n</code>, ...</td></tr>
<tr><td><code>r#&quot;...&quot;#</code>, etc.</td><td>Raw string literal, but can also contain <code>&quot;</code>.</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td><strong>Byte string literal</strong> <a href="https://doc.rust-lang.org/stable/reference/tokens.html#byte-and-byte-string-literals"><sup class="expert">REF</sup></a>; constructs ASCII <code>[u8]</code>, not a string.</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, etc.</td><td>Raw byte string literal, combination of the above.</td></tr>
<tr><td><code>'ü¶Ä'</code></td><td><strong>Character literal</strong> <a href="https://doc.rust-lang.org/stable/reference/tokens.html#character-and-string-literals"><sup class="expert">REF</sup></a>, can contain unicode.</td></tr>
<tr><td><code>b'x'</code></td><td>ASCII <strong>byte literal</strong>. <a href="https://doc.rust-lang.org/stable/reference/tokens.html#byte-literals"><sup class="expert">REF</sup></a></td></tr>
</tbody></table>
</div>
<h3 id="comments">Comments</h3>
<p>No comment.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Line comment, use these to document code flow or <em>internals</em>.</td></tr>
<tr><td><code>//!</code></td><td>Inner line <strong>doc comment</strong> <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/meta/doc.html#documentation"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments"><sup class="expert">REF</sup></a> for auto generated documentation.</td></tr>
<tr><td><code>///</code></td><td>Outer line doc comment, use these on types.</td></tr>
<tr><td><code>/*...*/</code></td><td>Block comment.</td></tr>
<tr><td><code>/*!...*/</code></td><td>Inner block doc comment.</td></tr>
<tr><td><code>/**...*/</code></td><td>Outer block doc comment.</td></tr>
<tr><td><code>```rust ... ```</code></td><td>In doc comments, include a <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">doc test</a> (doc code running on <code>cargo test</code>).</td></tr>
<tr><td><code>#</code></td><td>In doc tests, hide line from documentation (<code>```   # use x::hidden; ```</code>).</td></tr>
</tbody></table>
</div>
<h3 id="miscellaneous">Miscellaneous</h3>
<p>These sigils did not fit any other category but are good to know nonetheless.</p>
<div class="cheats">
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>!</code></td><td>Always empty <strong>never type</strong>. <sup>üöß</sup> <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#the-never-type-that-never-returns"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/fn/diverging.html#diverging-functions"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/std/primitive.never.html"><sup class="mid">STD</sup></a> <a href="https://doc.rust-lang.org/stable/reference/types.html?highlight=never#never-type"><sup class="expert">REF</sup></a></td></tr>
<tr><td><code>_</code></td><td>Unnamed variable binding, e.g., <code>|x, _| {}</code>.</td></tr>
<tr><td><code>_x</code></td><td>Variable binding explicitly marked as unused.</td></tr>
<tr><td><code>1_234_567</code></td><td>Numeric separator for visual clarity.</td></tr>
<tr><td><code>1_u8</code></td><td>Type specifier for <strong>numeric literals</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/types/literals.html#literals"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/tokens.html#number-literals"><sup class="expert">REF</sup></a>  (also <code>i8</code>, <code>u16</code>, ...).</td></tr>
<tr><td><code>0xBEEF</code>, <code>0o777</code>, <code>0b1001</code></td><td>Hexadecimal (<code>0x</code>), octal (<code>0o</code>) and binary (<code>0b</code>) integer literals.</td></tr>
<tr><td><code>r#foo</code></td><td>A <strong>raw identifier</strong> <a href="https://doc.rust-lang.org/book/appendix-01-keywords.html?highlight=raw,iten#raw-identifiers"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/stable/rust-by-example/compatibility/raw_identifiers.html?highlight=raw,iden#raw-identifiers"><sup class="entry">EX</sup></a> for edition compatibility.</td></tr>
<tr><td><code>x;</code></td><td><strong>Statement</strong> <a href="https://doc.rust-lang.org/stable/reference/statements.html"><sup class="expert">REF</sup></a> terminator, <em>c</em>. <strong>expressions</strong> <a href="https://doc.rust-lang.org/stable/rust-by-example/expression.html"><sup class="entry">EX</sup></a> <a href="https://doc.rust-lang.org/stable/reference/expressions.html"><sup class="expert">REF</sup></a></td></tr>
</tbody></table>
</div>
<h3 id="common-operators">Common Operators</h3>
<p>Rust supports all common operators you would expect to find in a language (<code>+</code>, <code>*</code>, <code>%</code>, <code>=</code>, <code>==</code>...).
Since they behave no differently in Rust we do not list them here.
For some of them Rust also supports <strong>operator overloading</strong>. <a href="https://doc.rust-lang.org/std/ops/index.html"><sup class="mid">STD</sup></a></p>
<h2 id="invisible-sugar">Invisible Sugar</h2>
<p>If something works that &quot;shouldn't work now that you think about it&quot;, it might be due to one of these.</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Coercions</strong> <a href="https://doc.rust-lang.org/nightly/nomicon/coercions.html"><sup class="expert">NOM</sup></a></td><td>'Weaken' types to match signature, e.g., <code>&amp;mut T</code> to <code>&amp;T</code>.</td></tr>
<tr><td><strong>Deref</strong> <a href="https://doc.rust-lang.org/nightly/nomicon/vec-deref.html#deref"><sup class="expert">NOM</sup></a></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a> <code>x: T</code> until <code>*x</code>, <code>**x</code>, ... compatible with some target <code>S</code>.</td></tr>
<tr><td><strong>Prelude</strong> <a href="https://doc.rust-lang.org/std/prelude/index.html"><sup class="mid">STD</sup></a></td><td>Automatic import of basic types.</td></tr>
<tr><td><strong>Reborrow</strong></td><td>Since <code>x: &amp;mut T</code> can't be copied; move new <code>&amp;mut *x</code> instead.</td></tr>
<tr><td><strong>Lifetime Elision</strong> <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision"><sup class="entry">BK</sup></a> <a href="https://doc.rust-lang.org/nightly/nomicon/lifetime-elision.html#lifetime-elision"><sup class="expert">NOM</sup></a> <a href="https://doc.rust-lang.org/stable/reference/lifetime-elision.html?highlight=lifetime,el#lifetime-elision"><sup class="expert">REF</sup></a></td><td>Automatically annotate <code>f(x: &amp;T)</code> to <code>f&lt;'a&gt;(x: &amp;'a T)</code>.</td></tr>
<tr><td><strong>Method Resolution</strong> <a href="https://doc.rust-lang.org/stable/reference/expressions/method-call-expr.html"><sup class="expert">REF</sup></a></td><td>Deref or borrow <code>x</code> until <code>x.f()</code> works.</td></tr>
</tbody></table>
<h2 id="closures">Closures</h2>
<p>There is a subtrait relationship <code>Fn</code> : <code>FnMut</code> : <code>FnOnce</code>. That means, a closure that
implements <code>Fn</code>, also implements <code>FnMut</code> and <code>FnOnce</code>. Likewise, a closure
that implements <code>FnMut</code>, also implements <code>FnOnce</code>.</p>
<p>From a call site perspective that means:</p>
<table><thead><tr><th>Signature</th><th>Function <code>g</code> can call ...</th><th>Function <code>g</code> accepts ...</th></tr></thead><tbody>
<tr><td><code>g&lt;F: FnOnce()&gt;(f: F)</code></td><td>... <code>f()</code> once.</td><td><code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code></td></tr>
<tr><td><code>g&lt;F: FnMut()&gt;(mut f: F)</code></td><td>... <code>f()</code> multiple times.</td><td><code>Fn</code>, <code>FnMut</code></td></tr>
<tr><td><code>g&lt;F: Fn()&gt;(f: F)</code></td><td>... <code>f()</code> multiple times.</td><td><code>Fn</code></td></tr>
</tbody></table>
<div class="footnotes">
    Notice how <b>asking</b> for a <code>Fn</code> closure as a function is
    most restrictive for the caller; but <b>having</b> a <code>Fn</code>
    closure as a caller is most compatible with any function.
</div>
<div>&nbsp;</div>
<p>From the perspective of someone defining a closure:</p>
<table><thead><tr><th>Closure</th><th>Implements<sup>*</sup></th><th>Comment</th></tr></thead><tbody>
<tr><td><code> || { moved_s; } </code></td><td><code>FnOnce</code></td><td>Caller must give up ownership of <code>moved_s</code>.</td></tr>
<tr><td><code> || { &amp;mut s; } </code></td><td><code>FnOnce</code>, <code>FnMut</code></td><td>Allows <code>g()</code> to change caller's local state <code>s</code>.</td></tr>
<tr><td><code> || { &amp;s; } </code></td><td><code>FnOnce</code>, <code>FnMut</code>, <code>Fn</code></td><td>May not mutate state; but can share and reuse <code>s</code>.</td></tr>
</tbody></table>
<div class="footnotes">
    <sup>*</sup> Rust <a href="https://doc.rust-lang.org/stable/reference/expressions/closure-expr.html">prefers capturing</a> by reference
    (resulting in the most "compatible" <code>Fn</code> closures from a caller perspective), but can be
    forced to capture its environment by copy or move via the
    <code>move || {}</code> syntax.
</div>
<div>&nbsp;</div>
<p>That gives the following advantages and disadvantages:</p>
<table><thead><tr><th>Requiring</th><th>Advantage</th><th>Disadvantage</th></tr></thead><tbody>
<tr><td><code>F: FnOnce</code></td><td><span class="good">Easy to satisfy as caller.</span></td><td><span class="bad">Single use only, <code>g()</code> may call <code>f()</code> just once.</span></td></tr>
<tr><td><code>F: FnMut</code></td><td><span class="good">Allows <code>g()</code> to change caller state.</span></td><td><span class="bad">Caller may not reuse captures during <code>g()</code>.</span></td></tr>
<tr><td><code>F: Fn</code></td><td><span class="good">Many can exist at same time.</span></td><td><span class="bad">Hardest to produce for caller.</span></td></tr>
</tbody></table>
<h2 id="idiomatic-rust">Idiomatic Rust</h2>
<p>If you are used to programming Java or C, consider these.</p>
<div class="cheats">
<table><thead><tr><th>Idiom</th><th>Code</th></tr></thead><tbody>
<tr><td><strong>Think in Expressions</strong></td><td><code>x = if x { a } else { b };</code></td></tr>
<tr><td></td><td><code>x = loop { break 5 };</code></td></tr>
<tr><td></td><td><code>fn f() -&gt; u32 { 0 }</code></td></tr>
<tr><td><strong>Think in Iterators</strong></td><td><code>(1..10).map(f).collect()</code></td></tr>
<tr><td></td><td><code>names.iter().filter(|x| x.starts_with(&quot;A&quot;))</code></td></tr>
<tr><td><strong>Handle Absence with <code>?</code></strong></td><td><code>x = try_something()?;</code></td></tr>
<tr><td></td><td><code>get_option()?.run()?</code></td></tr>
<tr><td><strong>Use Strong Types</strong></td><td><code>enum E { Invalid, Valid { ... } }</code> over <code>ERROR_INVALID = -1</code></td></tr>
<tr><td></td><td><code>enum E { Visible, Hidden }</code> over <code>visible: bool</code></td></tr>
<tr><td></td><td><code>struct Charge(f32)</code> over <code>f32</code></td></tr>
<tr><td><strong>Provide Builders</strong></td><td><code>Car::new(&quot;Model T&quot;).hp(20).run();</code></td></tr>
<tr><td><strong>Split Implementations</strong></td><td>Generic types <code>S&lt;T&gt;</code> can have a separate <code>impl</code> per <code>T</code>.</td></tr>
<tr><td></td><td>Rust doesn't have OO, but with separate <code>impl</code> you can get specialization.</td></tr>
<tr><td><strong>Unsafe</strong></td><td>Avoid <code>unsafe {}</code>, often safer, faster solution without it. Exception: FFI.</td></tr>
<tr><td><strong>Implement Traits</strong></td><td><code>#[derive(Debug, Copy, ...)]</code> and custom <code>impl</code> where needed.</td></tr>
<tr><td><strong>Tooling</strong></td><td>With <a href="https://github.com/rust-lang/rust-clippy"><strong>clippy</strong></a> you can improve your code quality.</td></tr>
<tr><td></td><td>Formatting with <a href="https://github.com/rust-lang/rustfmt"><strong>rustfmt</strong></a> helps others to read your code.</td></tr>
<tr><td></td><td>Add <strong>unit tests</strong> <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html"><sup class="entry">BK</sup></a> (<code>#[test]</code>) to ensure your code works.</td></tr>
<tr><td></td><td>Add <strong>doc tests</strong> <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html"><sup class="entry">BK</sup></a> (<code>``` my_api::f() ```</code>) to ensure docs match code.</td></tr>
<tr><td><strong>Documentation</strong></td><td>Annotate your APIs with doc comments that can show up on <a href="https://docs.rs"><strong>docs.rs</strong></a>.</td></tr>
<tr><td></td><td>Don't forget to include a <strong>summary sentence</strong> and the <strong>Examples</strong> heading.</td></tr>
<tr><td></td><td>If applicable: <strong>Panics</strong>, <strong>Errors</strong>, <strong>Safety</strong>, <strong>Abort</strong> and <strong>Undefined Behavior</strong>.</td></tr>
</tbody></table>
<!-- | **API Design** | Follow the [**API Guidelines**](https://rust-lang-nursery.github.io/api-guidelines/) ([**Checklist**](https://rust-lang-nursery.github.io/api-guidelines/checklist.html)) to make your API feel Rustic. | -->
<!-- |  | Add benchmarks (`#[bench]`) to ensure your code is fast. | -->
<div>&nbsp;</div>
<blockquote>
<p>üî• We <strong>highly</strong> recommend you also follow the
<a href="https://rust-lang-nursery.github.io/api-guidelines/"><strong>API Guidelines</strong></a> (<a href="https://rust-lang-nursery.github.io/api-guidelines/checklist.html"><strong>Checklist</strong></a>)
for any shared project! üî•</p>
</blockquote>
</div>
<div class="cheats">
<h2 id="a-guide-to-reading-lifetimes">A Guide to Reading Lifetimes</h2>
<p>Lifetimes can be overwhelming at times. Here is a simplified guide on how to read and interpret constructs containing lifetimes if you are familiar with C.</p>
<!-- > **Note**:
> This section is work in progress.
> For the time being, use with a grain of salt.
> Feedback very welcome! -->
<table><thead><tr><th>Construct</th><th>How to read</th></tr></thead><tbody>
<tr><td><code>let s: S = S(0)</code></td><td>A location that is <code>S</code>-sized, named <code>s</code>, and contains the value <code>S(0)</code>.</td></tr>
<tr><td></td><td>If declared with <code>let</code>, that location lives on the stack.</td></tr>
<tr><td></td><td>Generally, <code>s</code> can mean <em>location of <code>s</code></em>, and <em>value within <code>s</code></em>.</td></tr>
<tr><td></td><td>As a location, <code>s = S(1)</code> means, assign value <code>S(1)</code> to location <code>s</code>.</td></tr>
<tr><td></td><td>As a value, <code>f(s)</code> means call <code>f</code> with value inside of <code>s</code>.</td></tr>
<tr><td></td><td>To explicitly talk about its location (address) we do <code>&amp;s</code>.</td></tr>
<tr><td></td><td>To explicitly talk about a location that can hold such a location we do <code>&amp;S</code>.</td></tr>
<tr><td><code>&amp;'a S</code></td><td>A <code>&amp;S</code> is a <strong>location that can hold</strong> (at least) <strong>an address</strong>, called reference.</td></tr>
<tr><td></td><td>Any address stored in here must be that of a valid <code>S</code>.</td></tr>
<tr><td></td><td>Any address stored must <em>live</em> at least for (<em>outlive</em>) duration <code>'a</code>.</td></tr>
<tr><td></td><td>That means during <code>'a</code> memory targeted by <code>&amp;S</code> can't be invalidated.</td></tr>
<tr><td></td><td>During <code>'a</code> target of <code>&amp;S</code> may switch as long as new one also lives for <code>'a</code>.</td></tr>
<tr><td></td><td>Also, this <code>&amp;S</code> must be stopped being used before <code>'a</code> ends.</td></tr>
<tr><td></td><td>Duration of <code>'a</code> is purely compile time view, based on static analysis.</td></tr>
<tr><td><code>&amp;S</code></td><td>Sometimes <code>'a</code> might be elided (or can't be specified) but it still exists.</td></tr>
<tr><td></td><td>Within methods bodies, lifetimes are determined automatically.</td></tr>
<tr><td></td><td>Within signatures, lifetimes may be 'elided' (annotated automatically).</td></tr>
<tr><td><code>&amp;s</code></td><td>This will produce the <strong>actual address of location <code>s</code></strong>, called 'borrow'.</td></tr>
<tr><td></td><td>The moment <code>&amp;s</code> is produced, location <code>s</code> is put into a <strong>borrowed state</strong>.</td></tr>
<tr><td></td><td>Checking if in borrowed state is based on compile-time analysis.</td></tr>
<tr><td></td><td>This analysis is based on all possible address propagation paths.</td></tr>
<tr><td></td><td>As long as <strong>any</strong> <code>&amp;s</code> could be around, <code>s</code> cannot be altered directly.</td></tr>
<tr><td></td><td>For example, in <code>let a = &amp;s; let b = a;</code>, also <code>b</code> needs to go.</td></tr>
<tr><td></td><td>Borrowing of <code>s</code> stops once last <code>&amp;s</code> is last used, not when <code>&amp;s</code> dropped.</td></tr>
<tr><td><code>&amp;mut s</code></td><td>Same, but will produce a mutable borrow.</td></tr>
<tr><td></td><td>A <code>&amp;mut</code> will allow the <em>owner of the borrow</em> (address) to change <code>s</code> content.</td></tr>
<tr><td></td><td>This reiterates that not the value in <code>s</code>, but location of <code>s</code> is borrowed.</td></tr>
<tr><td><code>S&lt;'a&gt; {}</code></td><td>Signals that <code>S</code> will hold at least one address (i.e., reference).</td></tr>
<tr><td></td><td><code>'a</code> will be determined automatically by the user of this struct.</td></tr>
<tr><td></td><td><code>'a</code> will be chosen as small as possible.</td></tr>
<tr><td><code>f&lt;'a&gt;(x: &amp;'a T)</code></td><td>Signals this function will accept an address (i.e., reference).</td></tr>
<tr><td><span class="hidemobile">    </span> <span class="hidemobile">    </span> <span class="hidemobile">    </span> <span class="hidemobile">    </span> <code>-&gt; &amp;'a S</code></td><td>... and that it returns one.</td></tr>
<tr><td></td><td><code>'a</code> will be determined automatically by the caller.</td></tr>
<tr><td></td><td><code>'a</code> will be chosen as small as possible.</td></tr>
<tr><td></td><td><code>'a</code> will be picked so that it <strong>satisfies input and output</strong> at call site.</td></tr>
<tr><td></td><td><code>'a</code> is mix of where <code>x</code> comes from and <code>f(x)</code> goes.</td></tr>
<tr><td></td><td><strong>In addition, propagate borrow state</strong> according to lifetime names!</td></tr>
<tr><td></td><td>So while result address with <code>'a</code> is used, input address with <code>'a</code> is locked.</td></tr>
<tr><td></td><td>Here: while <code>s</code> from <code>let s = f(&amp;x)</code> is around, <code>x</code> counts as 'borrowed'.</td></tr>
<tr><td><code>&lt;'a, 'b: 'a&gt;</code></td><td>The lifetimes declared in <code>S&lt;&gt;</code> and <code>f&lt;&gt;</code> can also have bounds.</td></tr>
<tr><td></td><td>The <code>&lt;'a, 'b&gt;</code> part means the type will handle at least 2 addresses.</td></tr>
<tr><td></td><td>The <code>'b: 'a</code> part is a <strong>lifetime bound</strong>, and means <code>'b</code> must <strong>outlive</strong> <code>'a</code>.</td></tr>
<tr><td></td><td>Any address in an <code>&amp;'b X</code> must exist at least as long as any in an <code>&amp;'a Y</code>.</td></tr>
</tbody></table>
<div>&nbsp;</div>
</div>
<h2 id="formatting-strings">Formatting Strings</h2>
<p>Formatting applies to <code>print!</code>, <code>eprint!</code>, <code>write!</code> (and their -<code>ln</code> siblings like <code>println!</code>).
The <code>format!</code> macro can create a formatted <code>String</code>.</p>
<div class="cheats">
<p>Each format argument follows a basic grammar:</p>
<pre><code>{[argument][':'[[fill]align][sign]['#']['0'][width]['.' precision][type]]}
</code></pre>
<p>The full grammar is <a href="https://doc.rust-lang.org/std/fmt/index.html#syntax">specified in the
<code>std::fmt</code></a> documentation, but here are some commonly used flags:</p>
<table><thead><tr><th>Element</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>argument</code></td><td>Omitted (next <code>{}</code>), number (<code>0</code>, <code>1</code>, ...) or identifier for named arguments.</td></tr>
<tr><td><code>align</code></td><td>Left (<code>&lt;</code>), center (<code>^</code>), or right (<code>&gt;</code>) , if width is specified, fills with <code>fill</code>.</td></tr>
<tr><td><code>#</code></td><td><a href="https://doc.rust-lang.org/std/fmt/index.html#sign0">Alternate formatting</a>. Pretty-print with <code>{:#?}</code>, for example.</td></tr>
<tr><td><code>0</code></td><td>Zero-pads numeric values.</td></tr>
<tr><td><code>width</code></td><td>Minimum width (‚â• 0), padding with <code>fill</code> (default to space).</td></tr>
<tr><td><code>precision</code></td><td>Decimal digits (‚â• 0) for numerics, or max width for non-numerics.</td></tr>
<tr><td><code>type</code></td><td><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a> (<code>?</code>), hex (<code>x</code>), binary (<code>b</code>), or octal (<code>o</code>) (<a href="https://doc.rust-lang.org/std/fmt/index.html#traits">there are more, using Traits</a>).</td></tr>
</tbody></table>
<div class="footnotes">
    Note that <a href="https://doc.rust-lang.org/std/fmt/index.html#width">width</a> and <a href="https://doc.rust-lang.org/std/fmt/index.html#precision">precision</a> can use other arguments as their values, allowing for dynamic sizing of fields.
</div>
<div>&nbsp;</div>
<p>Examples:</p>
<table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{:#?}</code></td><td>Pretty-print the next argument using <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a>.</td></tr>
<tr><td><code>{2:#?}</code></td><td>Pretty-print the 3rd argument using <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a>.</td></tr>
<tr><td><code>{val:^2$}</code></td><td>Center the <code>val</code> named argument, width specified by the 3rd argument.</td></tr>
<tr><td><code>{:&lt;10.3}</code></td><td>Left align with width 10 and a precision of 3.</td></tr>
<tr><td><code>{val:#x}</code></td><td>Format <code>val</code> argument as hex, with a leading <code>0x</code> (alternate format for <code>x</code>).</td></tr>
</tbody></table>
</div>
<h2 id="tooling">Tooling</h2>
<p>Some commands and tools that are good to know.</p>
<table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cargo init</code></td><td>Create a new project for the latest edition.</td></tr>
<tr><td><code>cargo <span class="cargo-prefix">b</span>uild</code></td><td>Build the project in debug mode (<code>--release</code> for all optimization).</td></tr>
<tr><td><code>cargo <span class="cargo-prefix">c</span>heck</code></td><td>Check if project would compile (much faster).</td></tr>
<tr><td><code>cargo <span class="cargo-prefix">t</span>est</code></td><td>Run tests for the project.</td></tr>
<tr><td><code>cargo <span class="cargo-prefix">r</span>un</code></td><td>Run your project, if a binary is produced (main.rs).</td></tr>
<tr><td><code>cargo doc --open</code></td><td>Locally generate documentation for your code and dependencies.</td></tr>
<tr><td><code>cargo rustc -- -Zunpretty=X</code></td><td>Show more desugared Rust code, in particular with X being:</td></tr>
<tr><td><span class="hidemobile">    </span> <code>expanded</code></td><td>Show with expanded macros, ...</td></tr>
<tr><td><code>cargo +{nightly, stable} ...</code></td><td>Runs command with given toolchain, e.g., for 'nightly only' tools.</td></tr>
<tr><td><code>rustup docs</code></td><td>Open offline Rust documentation (incl. the books), good on a plane!</td></tr>
</tbody></table>
<div class="footnotes">
A command like <code>cargo <span class="cargo-prefix">b</span>uild</code> means you can either type <code>cargo build</code> or just <code>cargo b</code>.
</div>
<div>&nbsp;</div>
<p>These are optional <code>rustup</code> components.
Install them with <code>rustup component add [tool]</code>.</p>
<div class="cheats">
<table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cargo clippy</code></td><td>Additional (<a href="https://rust-lang.github.io/rust-clippy/master/">lints</a>) catching common API misuses and unidiomatic code. <a href="https://github.com/rust-lang/rust-clippy"><sup>üîó</sup></a></td></tr>
<tr><td><code>cargo fmt</code></td><td>Automatic code formatter (<code>rustup component add rustfmt</code>). <a href="https://github.com/rust-lang/rustfmt"><sup>üîó</sup></a></td></tr>
</tbody></table>
<div>&nbsp;</div>
<p>These are 3rd party tools and usually need to be installed with <code>cargo install cargo-[tool]</code> first.
They often require unstable and are subject to break.</p>
<div class="cheats">
<table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cargo asm</code></td><td>Show generated assembly instructions for code. <a href="https://github.com/gnzlbg/cargo-asm"><sup>üîó</sup></a></td></tr>
<tr><td><code>cargo outdated</code></td><td>List upgradable dependencies. <a href="https://github.com/kbknapp/cargo-outdated"><sup>üîó</sup></a></td></tr>
<tr><td><code>cargo tree</code></td><td>Print dependencies as a tree. <a href="https://github.com/sfackler/cargo-tree"><sup>üîó</sup></a></td></tr>
<tr><td><code>cargo-edit</code></td><td>Meta package (<code>cargo install cargo-edit</code>) <a href="https://github.com/killercup/cargo-edit"><sup>üîó</sup></a>. Provides:</td></tr>
<tr><td><span class="hidemobile">    </span> <code>cargo add &lt;crate&gt;</code></td><td>Add latest version of <code>&lt;crate&gt;</code> to your <code>Cargo.toml</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>cargo rm &lt;crate&gt;</code></td><td>Remove <code>&lt;crate&gt;</code> from your <code>Cargo.toml</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <code>cargo upgrade &lt;crate&gt;</code></td><td>Upgrade the version of <code>&lt;crate&gt;</code> to the latest.</td></tr>
<tr><td><code>cargo flamegraph</code></td><td>Visualize CPU time (<code>cargo install flamegraph</code>). <a href="https://github.com/ferrous-systems/flamegraph"><sup>üîó</sup></a> <sup>OSX, Linux only</sup></td></tr>
</tbody></table>
</div>
</div>
<!--

## Data Layout

Primitive types:

| Kind | 1 byte |  2 byte |  4 byte |  8 byte |  16 byte |
|---|---|---|---|---|---|---|---|
|**Signed**| `u8` |  `u16` |  `u32` |  `u64` |  `u128` |
|**Unsigned**| `i8` |  `i16` |  `i32` |  `i64` |  `i128` |
|**Float**|      |        |  `f32` |  `f64` |         |
|**Boolean**| `true`, `false` |        |  |   |         |

<div>&nbsp;</div>

Advanced types:

| Type | Bytes |  Description |
|--- |---|---|
|`()` | 0 | Unit types (also `struct S;`, `!`, ...) take up no memory. |
|`T`| `mem::xxx(T)` | If `x: T` moved might produce additional runtime drop flag. |
|`&T`| word<sup>*</sup> | References are plain pointers. |
|`&'a T`| word<sup>*</sup> | Same as `&T`, lifetimes disappear in assembly (contrasting move). |
|`&[T]`| 2 x word<sup>*</sup> | A slice is represented as `(ptr, len)`. |

&nbsp; &nbsp; <sup>*</sup> whatever word size is on machine, usually 4 or 8 bytes.
 -->
<!-- Don't render this section for printing, won't be helpful -->
<div class="noprint">
<h2 id="links-services">Links &amp; Services</h2>
<p>These are other great visual guides and tables.</p>
<a href="https:&#x2F;&#x2F;docs.google.com&#x2F;presentation&#x2F;d&#x2F;1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4&#x2F;edit">
    <div style="display:inline-block; margin-right: 30px; margin-bottom: 20px;">
        <div style="width:200px; height: 200px; background-image: linear-gradient(#00000005, #00000005);">
            <img style="position: relative; z-index: -10000" src="&#x2F;link_containers.png"></img>
        </div>
        <b>Containers</b>
    </div>
</a>
<a href="https:&#x2F;&#x2F;lukaslueg.github.io&#x2F;macro_railroad_wasm_demo&#x2F;">
    <div style="display:inline-block; margin-right: 30px; margin-bottom: 20px;">
        <div style="width:200px; height: 200px; background-image: linear-gradient(#00000005, #00000005);">
            <img style="position: relative; z-index: -10000" src="&#x2F;link_railroad.png"></img>
        </div>
        <b>Macro Railroad</b>
    </div>
</a>
<a href="https:&#x2F;&#x2F;rufflewind.com&#x2F;2017-02-15&#x2F;rust-move-copy-borrow">
    <div style="display:inline-block; margin-right: 30px; margin-bottom: 20px;">
        <div style="width:200px; height: 200px; background-image: linear-gradient(#00000005, #00000005);">
            <img style="position: relative; z-index: -10000" src="&#x2F;link_lifetimes.png"></img>
        </div>
        <b>Lifetimes</b>
    </div>
</a>
<div>&nbsp;</div>
<table><thead><tr><th>Cheat Sheets</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/ctjhoa/rust-learning">Rust Learning‚≠ê</a></td><td>Probably the best collection of links about learning Rust.</td></tr>
<tr><td><a href="https://github.com/JasonShin/functional-programming-jargon.rs">Functional Jargon in Rust</a></td><td>A collection of functional programming jargon explained in Rust.</td></tr>
<tr><td><a href="https://docs.google.com/spreadsheets/d/19vSPL6z2d50JlyzwxariaYD6EU2QQUQqIDOGbiGQC7Y/pubhtml?gid=0&amp;single=true">String Conversions</a></td><td>How to get type of string from another.</td></tr>
<tr><td><a href="http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types">Periodic Table of Types</a></td><td>How various types and references correlate.</td></tr>
<tr><td><a href="https://rufflewind.com/img/rust-futures-cheatsheet.html">Futures</a></td><td>How to construct and work with futures.</td></tr>
<tr><td><a href="https://danielkeep.github.io/itercheat_baked.html">Rust Iterator Cheat Sheet</a></td><td>Summary of iterator-related methods from <code>std::iter</code> and <code>itertools</code>.</td></tr>
<tr><td><a href="https://upsuper.github.io/rust-cheatsheet/">Type-Based Rust Cheat Sheet</a></td><td>Lists common types and how they convert.</td></tr>
</tbody></table>
<div>&nbsp;</div>
<p>All major Rust books developed by the community.</p>
<table><thead><tr><th>Books Ô∏èüìö</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a></td><td>Standard introduction to Rust, <strong>start here if you are new</strong>.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rust-lang-nursery.github.io/api-guidelines/">The API Guidelines</a></td><td>How to write idiomatic and re-usable Rust.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rust-lang.github.io/async-book/">The Async Book</a>  <sup>üöß</sup></td><td>Explains <code>async</code> code, <code>Futures</code>, ...</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://doc.rust-lang.org/nightly/edition-guide/">The Edition Guide</a></td><td>Working with Rust 2015, Rust 2018, and beyond.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://danielkeep.github.io/tlborm/book/index.html">The Little Book of Rust Macros</a> <sup>üöß</sup></td><td>Community's collective knowledge of Rust macros.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://doc.rust-lang.org/stable/reference/">The Reference</a> <sup>üöß</sup></td><td>Reference of the Rust language.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rust-lang.github.io/rfcs/">The RFC Book </a></td><td>Look up accepted RFCs and how they change the language.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rust-lang.github.io/rustc-guide/index.html">The Rustc Guide</a></td><td>Explains how the compiler works internally.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://doc.rust-lang.org/stable/rustdoc/">The Rustdoc Book</a></td><td>Tips how to customize <code>cargo doc</code> and <code>rustdoc</code>.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a></td><td>Dark Arts of Advanced and Unsafe Rust Programming.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rust-lang-nursery.github.io/packed_simd/perf-guide/">The SIMD Performance Guide</a> <sup>üöß</sup></td><td>Work with <code>u8x32</code> or <code>f32x8</code> to speed up your computations.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rust-lang.github.io/unsafe-code-guidelines/">The Unsafe Code Guidelines</a>  <sup>üöß</sup></td><td>Concise information about writing <code>unsafe</code> code.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://doc.rust-lang.org/unstable-book/index.html">The Unstable Book</a></td><td>Information about unstable items, e.g, <code>#![feature(...)]</code>.</td></tr>
<tr><td><a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a></td><td>How to use <code>cargo</code> and write <code>Cargo.toml</code>.</td></tr>
<tr><td><a href="https://rust-lang-nursery.github.io/cli-wg/">The CLI Book</a></td><td>Information about creating CLI tools.</td></tr>
<tr><td><a href="https://docs.rust-embedded.org/book/intro/index.html">The Embedded Book</a></td><td>Working with embedded and <code>#![no_std]</code> devices.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://docs.rust-embedded.org/embedonomicon/">The Embedonomicon</a></td><td>First <code>#![no_std]</code> from scratch on a Cortex-M.</td></tr>
<tr><td><a href="https://rustwasm.github.io/docs/book/">The WebAssembly Book</a></td><td>Working with the web and producing <code>.wasm</code> files.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rustwasm.github.io/docs/wasm-bindgen/">The <code>wasm-bindgen</code> Guide</a></td><td>How to bind Rust and JavaScript APIs in particular.</td></tr>
</tbody></table>
<div>&nbsp;</div>
<p>Comprehensive lookup tables for common components.</p>
<table><thead><tr><th>Tables üìã</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/error-index.html">Compiler Error Index</a></td><td>Ever wondered what <code>E0404</code> means?</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/">ALL the Clippy Lints</a></td><td>All the <a href="https://github.com/rust-lang/rust-clippy"><strong>clippy</strong></a> lints you might be interested in.</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/">Configuring Rustfmt</a></td><td>All <a href="https://github.com/rust-lang/rustfmt"><strong>rustfmt</strong></a> options you can use in <code>rustfmt.toml</code>.</td></tr>
<tr><td><a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md">Rust Changelog</a></td><td>See all the things that changed in a particular version.</td></tr>
<tr><td><a href="https://forge.rust-lang.org/">Rust Forge</a></td><td>Lists release train and links for people working on the compiler.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://forge.rust-lang.org/platform-support.html">Rust Platform Support</a></td><td>All supported platforms and their Tier.</td></tr>
<tr><td><span class="hidemobile">    </span> <a href="https://rust-lang.github.io/rustup-components-history/">Rust Component History</a></td><td>Check <strong>nightly</strong> status of various Rust tools for a platform.</td></tr>
</tbody></table>
<div>&nbsp;</div>
<p>Online services which provide information or tooling.</p>
<table><thead><tr><th>Services ‚öôÔ∏è</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/">crates.io</a></td><td>All 3rd party libraries for Rust.</td></tr>
<tr><td><a href="https://docs.rs/">docs.rs</a></td><td>Documentation for 3rd party libraries, automatically generated from source.</td></tr>
<tr><td><a href="https://libs.rs/">libs.rs</a></td><td>Unofficial overview of quality Rust libraries and applications.</td></tr>
<tr><td><a href="https://play.rust-lang.org/">Rust Playground</a></td><td>Try and share snippets of Rust code.</td></tr>
</tbody></table>
<div>&nbsp;</div>
<h2 id="printing-pdf">Printing &amp; PDF</h2>
<blockquote>
<p>Want this Rust cheat sheet as a PDF download? <a href="javascript:window.print()"><b>Generate PDF</b></a> (or select File &gt; Print ‚Äì might take 10s so) and then &quot;Save as PDF&quot;. It looks great in both Firefox's and Chrome's PDF exports. Alternatively use the <a href="rust_cheat_sheet.pdf"><b>cached PDF</b></a>.</p>
</blockquote>
</div>
<footer>Ralf Biedert, 2019 ‚Äì <a href="https://cheats.rs">cheats.rs</a></footer>

            </div>
        </div>
    </div>


    <!-- Github ribbon -->
    <a class="noprint" href="https://github.com/ralfbiedert/cheats.rs/"><img
            style="position: absolute; top: 0; right: 0; border: 0;"
            src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>

    <!-- Syntax highlighting -->
    <script type="text/javascript" src="https://cheats.rs/prism.js"></script>
    <script type="text/javascript">
        let codes = document.querySelectorAll("code");
        let iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent); // https://stackoverflow.com/questions/9038625/detect-if-device-is-ios


        /// Enables or disables the playground.
        function show_playground(state) {
            let area_static = document.getElementById("hellostatic");
            let area_play = document.getElementById("helloplay");
            let area_ctrl = document.getElementById("helloctrl");

            if (state) {
                area_static.style = 'display: none;';
                area_play.innerHTML = '<iframe src="https://play.rust-lang.org/" style="width:100%; height:500px;"></iframe>';
                area_ctrl.innerHTML = '<a href="javascript:show_playground(false);">‚èπÔ∏è Stop Editor</a>';
            } else {
                area_static.style = 'display: block;';
                area_play.innerHTML = '';
                area_ctrl.innerHTML = '<a href="javascript:show_playground(true);">‚ñ∂Ô∏è Edit & Run</a>';
            }
        }

        // Called by toggle button, enable or disable night mode and persist setting in localStorage.
        function toggle_night_mode() {
            let body = document.getElementsByTagName("body")[0];
            if (body.classList.contains("night-mode")) {
                body.classList.remove("night-mode");
                localStorage.setItem('night-mode', 'day');
            } else {
                body.classList.add("night-mode");
                localStorage.setItem('night-mode', 'night');
            }
        }

        // Called by toggle button, enable or disable ligatures persist setting in localStorage.
        function toggle_ligatures() {
            let body = document.getElementsByTagName("body")[0];
            let set = undefined;

            if (codes[0].style.fontVariantLigatures == "common-ligatures") {
                set = "none";
                localStorage.setItem('ligatures', 'no-ligatures');
            } else {
                set = "common-ligatures";
                localStorage.setItem('ligatures', 'ligatures');
            }

            codes.forEach(code => {
                code.style.fontVariantLigatures = set;
            })
        }

        // Use proper syntax since we don't want to write ````rust ...``` all the time.
        codes.forEach(code => {
            code.className = "language-rust";
        });


        // Executed on page load, this runs all toggles the user might have clicked
        // the last time based on localStorage.
        try {
            let night_mode = localStorage.getItem('night-mode');
            let ligatures = localStorage.getItem('ligatures');

            if (night_mode === "night") {
                toggle_night_mode();
            }

            if (ligatures === "ligatures") {
                toggle_ligatures();
            }

            // iOS does not honor the ligature settings and always renders the font without them.
            // Hide the button not to confuse users.
            if (iOS) {
                let button = document.getElementById("toggle_ligatures");
                button.style.visibility = "hidden";
            }
        } catch (e) {
            console.log(e);
        }
    </script>
</body>

</html>